Привет всем хабровчанам, любителям <b>Yii</b> и <b>Node.js</b>. Продолжаю серию статей про <a href="http://www.jiiframework.ru">Jii Framework</a>.
Сегодня настал момент релиза комета, о котором я и расскажу в этой статье.

<img src="https://habrastorage.org/files/c04/cc0/3b8/c04cc03b88cb4c61a1c8cda3fde2b632.jpg"/>

<a href="https://github.com/jiisoft/jii-comet"><b>Jii-comet</b></a> - это масштабируемый, готовый к высоким нагрузкам и плохому интернету транспорт, реализующий постоянную связь между клиентом и сервером для мгновенного обмена данными.

Jii-comet предоставляет набор компонентов и классов, которые упрощают обмен сообщениями между каналами, подписки на них, обмена данными между серверами и так далее. Сам модуль не умеет доставлять сообщения на клиент и обратно, но в нем заложена абстракция, чтобы это можно было делать любой из существующих популярных библиотек (например, <a href="http://socket.io/">socket.io</a>, <a href="https://github.com/sockjs/sockjs-client">sockjs</a>), а так же чтобы это было надежно и масштибаруемо.
<cut />
Для тех, кто в первый раз слышит об этом фреймворке, рекомендую прочитать <a href="http://habrahabr.ru/search/?q=%5Bjii%5D&target_type=posts">предыдущие статьи</a> или <a href="http://jiiframework.ru">посетить сайт</a>. Если коротко, то
<blockquote>Jii - это фреймфорк, архитектура и API которого базируется на PHP фреймворке Yii 2.0, взяв из него лучшие стороны и сохраняя приемущества JavaScript.</blockquote>
<h1>Обзор</h1>
Для начала немного справки о том, что такое комет (<a href="https://ru.wikipedia.org/wiki/Comet_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">wiki</a>):
<blockquote>Comet (в веб-разработке) — любая модель работы веб-приложения, при которой постоянное HTTP-соединение позволяет веб-серверу отправлять (push) данные браузеру без дополнительного запроса со стороны браузера.</blockquote>
<h2>Возможности Jii-comet</h2>
Клиент:
<ul>
    <li>Отправка и прием сообщений из каналов</li>
    <li>Подписка на каналы</li>
    <li>Вызов действий на сервере</li>
    <li>Балансировка (случайный выбор сервера)</li>
    <li>Возможность смены транспорта сообщений</li>
</ul>
Сервер:
<ul>
    <li>Отправка и прием сообщений из каналов</li>
    <li>Подписка на сообщения из канала</li>
    <li>Подписывание соединения на канал</li>
    <li>Отправка сообщений в соединение</li>
    <li>Возможность смены транспорта сообщений, хаба и очереди</li>
    <li>Масштабирование на несколько процессов и серверов</li>
    <li>Режим listen-only (прослушивание каналов)</li>
    <li>Запуск действий из очереди</li>
</ul>
<h2>Установка</h2>
Комет устанавливается как <a href="http://www.jiiframework.ru/guide/structure-application-components">компонент приложения</a>, на сервере и клиенте соответственно. На сервере комет открывает и "слушает" данные из указанного порта, а клиент при инициализации приложения подключается к этому порту и ждет информацию.

Рассмотрим пример приложения, где клиент подписывается на сервере на канал <i>test</i> и отправляет в него сообщение.
Сервер:

<source language="javascript">
var Jii = require('jii');
require('jii-comet');

require('jii-workers')
    .application('comet', Jii.mergeConfigs(
        {
            application: {
                basePath: __dirname,
                components: {
                    comet: {
                        className: 'Jii.comet.server.Server',
                        port: 4401,

                        /**
                         *
                         * @param {Jii.comet.server.ConnectionEvent} event
                         */
                        'on addConnection': function(event) {
                            Jii.app.comet.subscribe(event.connection.id, 'test');
                        }
                    }
                }
            }
        },
        custom.comet || {}
    ));
</source>
Клиент:

<source language="javascript">
require('jii/deps');
require('jii-comet/sockjs');

Jii.createWebApplication({
    application: {
        basePath: location.href,
        components: {
            comet: {
                className: 'Jii.comet.client.Client',
                serverUrl: 'http://localhost:4401/comet',

                /**
                 *
                 * @param {Jii.base.Event} event
                 */
                'on open': function(event) {
                    Jii.app.comet.send('test', {message: 'Hello World'});
                },

                /**
                 *
                 * @param {Jii.comet.ChannelEvent} event
                 */
                'on channel:test': function(event) {
                    console.log('Income message: ' + event.params.message);
                }
            }
        }
    }
}).start();
</source>
Далее делально рассмотрим серверные и клиентские компоненты.

<h1>Комет-сервер</h1>
<img src="https://habrastorage.org/files/fab/f7a/243/fabf7a24320a4f25964953d5fe1aae57.jpg" align="center"/>
<b>Jii-comet</b> предоставляет два класса для создания сервера:
<ul>
	<li><i>Jii.comet.server.HubServer</i> - сервер, настроенный только для прослушивания сообщений от соединений, при этом самих подключений у него нет, но он может отправить данные в подключение, находящееся в соседнем процессе. Т.е. в такой сервер напрямую (на порт) невозможно подключиться, однако сообщение можно отправить через другие процессы (к которым подключены клиенты).</li>
	<li><i>Jii.comet.server.Server</i> - полноценный сервер, унаследован он предыдущего. Хранит и поддерживает прямое соединение с клиентами, может обмениваться данными с клиентом.</li>
</ul>
Такое резделение необходимо для гибкого масштабирования приложения. Например, вы можете создать несколько процессов с компонентом <i>Jii.comet.server.Server</i>, которые будут только поддерживать соединение с клиентами, но не обрабатывать бизнес логику. И создать несколько процессов <i>Jii.comet.server.HubServer</i>, которые будут выполнять тяжелые вычесления. Это позволит сделать комет-канал более отзывчивым: если бы все операции были бы на одном сервере, то сложные операции затормаживали бы процесс, и все последующие запросы (даже легкие) были бы с задержкой.

Если у вас нет больших нагрузок или вы не знаете что выбрать, выбирайте компонент <i>Jii.comet.server.Server</i>, так как он содержит в себе весь функционал.

Пример конфигурации для сервера выглядит так:

<source language="javascript">
application: {
    components: {
        comet: {
            className: 'Jii.comet.server.Server',
            host: '0.0.0.0',
            port: 3100
        },

        // ...
    }
}
</source>
Полный список свойств, методов и событий представлен ниже.

<h3>Jii.comet.server.HubServer</h3>
<h4>Свойства</h4>
<ul>
	<li><i>listenActions</i> (boolean) - принимать ли запросы на вызов действий от клиентов. По-умолчанию, <i>true</i>.</li>
	<li><i>hub</i> (object) - хаб, компонент или его конфигурация, имплементирующий интерфейс <i>Jii.comet.server.hub.HubInterface</i> для обмена сообщениями между процессами или серверами. По-умолчанию создается компонент <i>Jii.comet.server.hub.Redis</i>.</li>
	<li><i>queue</i> (object) - очередь, компонент или его конфигурация, имплементирующий интерфейс <i>Jii.comet.server.queue.QueueInterface</i> для накопления очереди вызовов действий (actions). По-умолчанию создается компонент <i>Jii.comet.server.queue.Redis</i>.</li>
</ul>
<h4>Методы</h4>
<ul>
	<li><i>start()</i> - открывает соединение для компонентов <i>hub</i> и <i>queue</i>, начинает слушать сообщения из каналов.</li>
	<li><i>stop()</i> - разрывает все соединения компонентов и перестает слушать информацию из вне.</li>
	<li><i>sendToChannel(channel, data)</i> - отправляет сообщение в канал в рамках хаба. Здесь <i>channel</i> - (string) название канала, а <i>data</i> - (string|object|*) данные для отправки.</li>
	<li><i>sendToConnection(id, data)</i> - как и предыдущий метод, отправляет данные, но не в канал, а напрямую в соединение. Здесь <i>id</i> (string) - это идентификатор соединения, взятый из <i>Jii.comet.server.Connection</i>, а <i>data</i> - (string|object|*) данные для отправки.</li>
	<li><i>on(name, handler, data, isAppend)</i> и <i>off(name, handler)</i> - методы для подписки и отписки на события. Список событий описан ниже, описание агрументов можно найти в <a href="http://www.jiiframework.ru/guide/concept-events">разделе событий</a>.</li>
	<li><i>hasChannelHandlers(name)</i> - Вовращает <i>true</i>, если на канал <i>name</i> (string) есть подписчики в рамках данного процесса.</li>
</ul>
<h4>События</h4>
<ul>
	<li><i>channel</i> - Событие запускается при любом входящем сообщении в любой канал. Первым агрументом обработчика будет передан экземпляр класса <i>Jii.comet.ChannelEvent</i> с параметрами <i>channel</i> (string) и <i>message</i> (string).</li>
	<li><i>channel:%my_channel_name%</i> - Событие запускается при любом входящем сообщении в канал, указанный после </i>:</i>. Например, при вызове <i>Jii.app.comet.on('channel:test', ...)</i> происходит подписка на сообщения в канал <i>test</i>. Как и выше, в обработчик события первым аргументом будет передан экземпляр класса <i>Jii.comet.ChannelEvent</i> с параметрами <i>channel</i> (string) и <i>message</i> (string).</li>
	<li><i>message</i> - Событие запускается при любом входящем сообщении в хаб. Первым агрументом обработчика будет передан экземпляр класса <i>Jii.comet.server.MessageEvent</i> с параметром <i>message</i> (string).</li>
</ul>
<h3>Jii.comet.server.Server</h3>
Наследует вышеперечисленные свойства, методы и события и добавляет следующие:

<h4>Свойства</h4>
<ul>
	<li><i>host</i> (string) - хост, ожидающий входящие соединения от клиентов. По-умолчанию, <i>0.0.0.0</i>.</li>
	<li><i>port</i> (number) - порт для входящих соединений. По-умолчанию, <i>4100</i>.</li>
	<li><i>transport</i> (object) - компонент или его конфигурация, имплементирующий интерфейс <i>Jii.comet.server.transport.TransportInterface</i> для обмена сообщениями непосредственно с клиентами (браузером).</li>
</ul>
<h4>Методы</h4>
<ul>
	<li><i>subscribe(connectionId, channel)</i> и <i>unsubscribe(connectionId, channel)</i> - подписывает и отписывает соединение на заданный канал. Jii рекомендует делать подписку на канал именно на сервере, чтобы избежать гонки сообщений. В методах <i>connectionId</i> (string) - это идентификатор соединения, взятый из <i>Jii.comet.server.Connection</i>, а <i>channel</i> (string) - имя канала.</li>
</ul>
<h4>События</h4>
<ul>
	<li><i>addConnection</i> - Событие возникает при присоединении нового клиента. Первым агрументом обработчика будет передан экземпляр класса <i>Jii.comet.server.ConnectionEvent</i> с параметром <i>connection</i> (<i>Jii.comet.server.Connection</i>).</li>
	<li><i>removeConnection</i> - Событие возникает при потере соединения с клиентом. Аналогично предыдущему, первым агрументом обработчика будет передан экземпляр класса <i>Jii.comet.server.ConnectionEvent</i>.</li>
</ul>
<h3>Jii.comet.server.Connection</h3>
Содержит информацию о соединении с клиентом

<h4>Свойства</h4>
<ul>
	<li><i>id</i> (string) - идентификатор соединения. Используется для отправки сообщений напрямую в соединение.</li>
	<li><i>request</i> (<i>Jii.comet.server.Request</i>) - информация о соединении: заголовки, ip адрес, порт подключения и так далее.</li>
	<li><i>originalConnection</i> (object) - внутренний экземпляр соединения, полученный от транспорта. Специфичен для каждого транспорта.</li>
</ul>
<h1>Комет-клиент</h1>
<img src="https://habrastorage.org/files/097/b90/0aa/097b900aa4ea472e801b8f91567df656.jpg" align="center"/>
На клиенте немного проще: есть один компонент <i>Jii.comet.client.Client</i>, который подключается к одному из серверов и обменивается данными.

<source language="javascript">
application: {
    components: {
        comet: {
            className: 'Jii.comet.client.Client',
            serverUrl: 'http://localhost:4401/comet',
            autoOpen: true
        },

        // ...
    }
}
</source>
Полный список свойств, методов и событий представлен ниже.

<h3>Jii.comet.client.Client</h3>
<h4>Свойства</h4>
<ul>
	<li><i>transport</i> (object) - компонент или его конфигурация, имплементирующий интерфейс <i>Jii.comet.client.transport.TransportInterface</i> для обмена сообщениями с сервером.</li>
	<li><i>plugins</i> (object) - набор компонентов или их конфигурация, каждый из которых имплементирует интерфейс <i>Jii.comet.client.plugin.PluginInterface</i> для расширения возможностей комет клиента.</li>
	<li><i>workersCount</i> (number|null) - максимальное количество воркеров сервера. Эта настройка используется для балансировки нагрузки на клиенте. По-умолчанию, <i>null</i> - отключена.</li>
	<li><i>autoOpen</i> (boolean) - если указано <i>true</i>, то при инициализации приложения комет клиент автоматически будет подключаться к серверу. По-умолчанию, <i>true</i>.</li>
</ul>
<h4>События</h4>
<ul>
	<li><i>open</i> - Событие запускается при успешном открытии соединения.</li>
	<li><i>close</i> - Событие запускается при закрытии соединения.</li>
	<li><i>beforeSend</i> - Событие запускается при любом исходящем сообщении. Первым аргументом обработчика будет передан экземпляр класса <i>Jii.comet.client.MessageEvent</i> с параметром <i>message</i>. Вы можете изменить отправляемое сообщение, изменяя параметр <i>message</i>, на сервер отправятся данные из параметра <i>message</i>.</li>
	<li><i>channel</i> - Событие запускается при любом входящем сообщении в любой подписанный канал. Первым агрументом обработчика будет передан экземпляр класса <i>Jii.comet.ChannelEvent</i> с параметрами <i>channel</i> (string) и <i>message</i> (string).</li>
	<li><i>channel:%my_channel_name%</i> - Событие запускается при любом входящем сообщении в подписанный канал, указанный после <i>:</i>. Например, при вызове <i>Jii.app.comet.on('channel:test', ...)</i> происходит подписка на сообщения в канал <i>test</i>. Как и выше, в обработчик события первым аргументом будет передан экземпляр класса <i>Jii.comet.ChannelEvent</i> с параметрами <i>channel</i> (string) и <i>message</i> (string).</li>
	<li><i>message</i> - Событие запускается при любом входящем сообщении. Первым агрументом обработчика будет передан экземпляр класса <i>Jii.comet.server.MessageEvent</i> с параметром <i>message</i> (string).</li>
	<li><i>beforeRequest</i> - Событие запускается перед тем, как клиент пытается отправить на сервер запрос на выполнения действия. Первым аргументом обработчика будет передан экземпляр класса <i>Jii.comet.client.RequestEvent</i> с параметрами <i>route</i> (string) и <i>params</i> (object). Вы можете изменить параметры запроса в этом событии, на сервер отправятся данные из параметра <i>params</i>.</li>
	<li><i>request</i> - Событие запускается при ответе сервера на запрошенное ранее действие. Первым аргументом обработчика будет передан экземпляр класса <i>Jii.comet.client.RequestEvent</i> с параметрами <i>route</i> (string) и <i>params</i> (object).</li>
</ul>
<h2>Плагины</h2>
Плагины позволяют расширять возможности комет клиента. По-умолчанию, установлен плагин для автоматического восстановления соединения <i>Jii.comet.client.plugin.AutoReconnect</i>. Плагин очень прост в создании и подключении. Интерфейс плагина <i>Jii.comet.client.plugin.PluginInterface</i> не требует имплементации методов, а лишь предоставляет доступ к комет-клиенту через параметр <i>comet</i>, через который можно подписываться на события комета. Устанавливается и настраивается плагин через конфигурацию, путем добавления его в секцию <i>plugins</i>:

<source language="javascript">
application: {
    components: {
        comet: {
            className: 'Jii.comet.client.Client',
            // ...
            plugins: {
                autoReconnect: {
                    enable: false
                },
                myPlugin: {
			        className: 'app.components.MyCometPlugin'
                }
            }
        },

        // ...
    }
}
</source>
<h1>Как это работает</h1>
<img src="https://habrastorage.org/files/59f/0a7/613/59f0a7613f0b4226945a382f41a39cf2.jpg" align="center"/>
С первого взгляда, jii-comet - это обертка над библиотекой комет-транспорта (sockjs, socket.io - на выбор), однако это не так. От библиотеки транспорта берется только функционал доставки сообщения на клиент и обратно. Реализация каналов, подписок, масштабирования и дополнительных фишек сделано именно в jii-comet. Архитектурно "под капотом" jii-comet разбит на следующие составляющие:

Сервер:
<ul>
	<li>Транспорт (<i>Jii.comet.server.transport.TransportInterface</i>) - абстракция для обмена сообщениями между клиентом и сервером.</li>
	<li>Хаб (<i>Jii.comet.server.hub.HubInterface</i>) - абстракция для обмена сообщениями между процессами и серверами.</li>
	<li>Очередь (<i>Jii.comet.server.queue.QueueInterface</i>) - абстракция для накопления вызовов действий.</li>
	<li>Соединение (<i>Jii.comet.server.Connection</i>) - экземпляр данного класса содержит информацию о соединении и доступен как <a href="http://www.jiiframework.ru/guide/structure-context-components">компонент контекста</a>.</li>
</ul>
Клиент:
<ul>
	<li>Транспорт (<i>Jii.comet.client.transport.TransportInterface</i>) - абстракция для обмена сообщениями между клиентом и сервером.</li>
	<li>Плагин (<i>Jii.comet.client.plugin.PluginInterface</i>) - абстракция для расширения возможностей комет клиента. По-умолчанию, установлен плагин для автоматического восстановления соединения <i>Jii.comet.client.plugin.AutoReconnect</i>.</li>
</ul>
Все эти абстракции могут настраиваться и переопределяться через <a href="http://www.jiiframework.ru/guide/concept-configurations">конфигурацию</a> приложения и контекста.

<h2>Примеры</h2>
<ul>
Ниже рассмотрим несколько примеров того, как может ходить сообщение между клиентами и серверами. Предположим, что в нашей системе имеется:
	<li>несколько клиентов</li>
	<li>несколько серверных процессов только для поддержания соединений (<i>Jii.comet.server.Server</i> и <i>listenActions</i> = <i>false</i>)</li>
	<li>несколько серверных процессов для поддержания соединений и обработки действий (<i>Jii.comet.server.Server</i> и <i>listenActions</i> = <i>true</i>)</li>
	<li>несколько серверных процессов только для обработки действий (<i>Jii.comet.server.HubServer</i> и <i>listenActions</i> = <i>true</i>)</li>
</ul>
<h3>Пример: Клиент отправляет сообщение в канал</h3>

<img src="https://habrastorage.org/files/7cb/96b/cdc/7cb96bcdcfcd4c69b07542c9f1bf873a.png" alt="jii-comet: Клиент отправляет сообщение в канал" align="center"/>

<ol>
	<li>Клиент отправляет сообщение в канал <i>test</i>.</li>
	<li>Серверный процесс, поддерживающий соединение принимает это сообщение и отправляет в хаб (<i>Jii.comet.server.hub.HubInterface</i>).</li>
	<li>Хаб рассылает это сообщение всем серверным процессам, которые подписаны на данный канал (или подписаны их соединения).</li>
	<li>Серверные процессы получают сообщение и отправляют соединениям, которые на него подписаны.</li>
</ol>
<h3>Пример: Клиент вызывает действие на сервере</h3>

<img src="https://habrastorage.org/files/1af/055/c8d/1af055c8d58d4a8dbc023e2df62ba39e.png" alt="jii-comet: Клиент вызывает действие на сервере" align="center"/>
<ol>
	<li>Клиент отправляет запрос на вполнение действия <i>site/test</i>.</li>
	<li>Серверный процесс, поддерживающий соединение принимает его и скидывает в очередь действий (<i>Jii.comet.server.queue.QueueInterface</i>), а так же через хаб (<i>Jii.comet.server.hub.HubInterface</i>) рассылает уведомление всем серверам, обрабатывающим действия (<i>listenActions</i> = <i>true</i>) о том, что очередь обновилась.</li>
	<li>Один из серверных процессов с <i>listenActions</i> = <i>true</i> вытаскивает запрос из очереди (методом <a href="http://redis.io/commands/lpop">lpop</a> в имплементации Redis'а) и запускает у себя действие.</li>
	<li>После выполнения действия, серверный процесс отправляет результат дейстивия (response) обратно клиенту. Поскольку данный серверный процесс не имеет прямого соединения с клиентом, он отправляет его в хаб (<i>Jii.comet.server.hub.HubInterface</i>).</li>
	<li>Хаб отправляет сообщение серверному процессу, подписаному на сообщения для этого соединения.</li>
	<li>Серверный процесс, поддерживающий это соединение получает сообщение и отправляет его непосредственно клиенту.</li>
</ol>
В третьем пункте запрос из очереди мог вытянуть любой серверный процесс с <i>listenActions</i> = <i>true</i>. Работает это по принципу "кто успел" и, как правило, успевать будет наименее нагруженный сервер. Таким образом, производится балансировка вызовов действий между серверами и их процессами.

<h2>Внутренний канал связи</h2>
Jii-comet имеет абстракцию, позволяющую использовать любую библиотеку в качестве внутреннего канала связи между клиентом и сервером. На данный момент сделан адаптер для библиотеки <a href="https://github.com/sockjs/sockjs-client">sockjs</a>, в будущем появится и для <a href="http://socket.io/">socket.io</a>.

В конфигурации транспорт объявляется в секции <i>transport</i>. По-умолчанию, используется класс <i>Jii.comet.server.transport.Sockjs</i> на севере и <i>Jii.comet.client.transport.Sockjs</i> на клиенте.
Транспорт можно конфигурировать и переопределять через конфигурацию:

<source language="javascript">
comet: {
    className: 'Jii.comet.client.Client',
    transport: {
        className: 'Jii.comet.client.transport.Sockjs',
        transports: [
            'websocket',
            'xhr-streaming',
            'xdr-streaming',
            'jsonp-polling'
        ]
    }
}
</source>
<h1>The End</h1>
Сайт фреймворка - <a href="http://www.jiiframework.ru/">jiiframework.ru</a>
GitHub - <a href="https://github.com/jiisoft">github.com/jiisoft</a>
Пожелания и предложения отправляйте на affka@affka.ru

<blockquote><h2>Нравится идея фреймворка? Ставь <a href="https://github.com/jiisoft/jii/stargazers">звезду</a> на <a href="https://github.com/jiisoft/jii">гитхабе</a>!</h2></blockquote>
<spoiler title="Навигация по статьям">
    <ul>
        <li><a href="http://habrahabr.ru/post/268361/">Jii: Полноценное приложение с архитектурой Yii2 в браузере</a></li>
        <li><a href="http://habrahabr.ru/post/266929/">Jii: конфигурация и масштабирование</a></li>
        <li><a href="http://habrahabr.ru/post/260931/">Jii — JavaScript фреймворк с архитектурой от Yii 2</a></li>
        <li><a href="http://habrahabr.ru/post/260569/">Jii: Active Record для Node.js с API от Yii 2</a></li>
        <li><a href="http://habrahabr.ru/post/260295/">Jii: Полноценный Query Builder для Node.js с API от Yii 2</a></li>
    </ul></spoiler>