События
======

События - это механизм, внедряющий элементы собственного кода в существующий код в определенные моменты его исполнения.
К событию можно присоединить собственный код, который будет выполняться автоматически при срабатывании события.
Например, объект, отвечающий за почту, может инициировать событие `messageSent` при успешной отправке сообщения.
При этом если нужно отслеживать успешно отправленные сообщения, достаточно присоединить соответствующий код к событию
`messageSent`.

Для работы с событиями Jii использует базовый класс [[Jii.base.Component]]. Если класс должен инициировать события,
его нужно унаследовать от [[Jii.base.Component]] или потомка этого класса.


Обработчики событий
--------------

Обработчик события - это функция, которая выполняется при срабатывании события, к которому она присоединена.
Сигнатура обработчика события выглядит следующим образом:

```js
function (event) {
    // event - это объект класса Jii.base.Event или его потомка
}
```

Через параметр `event` обработчик события может получить следующую информацию о возникшем событии:

- [[Jii.base.Event.name]] имя события
- [[Jii.base.Event.sender]] объект, метод `trigger()` которого был вызван
- [[Jii.base.Event.data]] данные, которые были предоставлены во время присоединения обработчика события (см. ниже)


Присоединение обработчиков событий
------------------------

Обработчики события присоединяются с помощью метода [[Jii.base.Component.on()]]. Например:

```js
foo = new Foo();

// обработчик - глобальная функция
foo.on(Foo.EVENT_HELLO, 'function_name');

// обработчик - метод объекта
foo.on(Foo.EVENT_HELLO, [object, 'methodName');

// обработчик - статический метод класса
foo.on(Foo.EVENT_HELLO, ['app.components.Bar', 'methodName');

// обработчик - анонимная функция
foo.on(Foo.EVENT_HELLO, function ($event) {
    // логика обработки события
});
```

Также обработчики событий можно присоединять с помощью [конфигураций](concept-configurations). Дополнительную
информацию см. в разделе [Конфигурации](concept-configurations#configuration-format).

Присоединяя обработчик события, можно передать дополнительные данные с помощью третьего параметра метода
[[Jii.base.Component.on()]]. Эти данные будут доступны в обработчике, когда сработает событие и он будет
вызван. Например:

```js
// Следующий код выводит "abc" при срабатывании события
// так как в event.data содержатся данные, которые переданы в качестве третьего аргумента метода "on"
foo.on(Foo.EVENT_HELLO, 'function_name', 'abc');

function function_name(event) {
    console.log(event.data); // abc
}
```

Порядок обработки событий
-------------------

К одному событию можно присоединить несколько обработчиков. При срабатывании события обработчики будут вызываться
в том порядке, к котором они присоединялись к событию. Чтобы запретить в обработчике вызов всех следующих за ним
обработчиков, необходимо установить свойство [[Jii.base.Event.handled]] параметра `event` в true:

```js
foo.on(Foo.EVENT_HELLO, function (event) {
    event.handled = true;
});
```

По умолчанию, новые обработчики присоединяются к концу очереди обработчиков, уже существующей у события.
В результате при срабатывании события обработчик выполнится последним.
Чтобы обработчик присоединился к началу очереди и запускался первым, при вызове [[Jii.base.Component.on()]] в качестве
четвертого параметра `append` следует передать false:

```js
foo.on(Foo.EVENT_HELLO, function (event) {
    // ...
}, data, false);
```

Инициирование событий
-----------------

События инициируются при вызове метода [[Jii.base.Component.trigger()]]. Методу нужно передать *имя события*,
а при необходимости - объект события, в котором описываются параметры, передаваемые обработчикам событий. Например:

```js
var Jii = require('jii');

/**
 * @class app.components.Foo
 * @extends Jii.base.Component
 */
Jii.defineClass('app.components.Foo', /** @lends app.components.Foo.prototype */{

	__extends: Jii.base.Component,
	
	__static: {
	    EVENT_HELLO: 'hello'
	},
	
	bar: function() {
        this.trigger(this.__static.EVENT_HELLO);
	}

});
```

Показанный выше код инициирует событие `hello` при каждом вызове метода `bar()`.

> Подсказка: Желательно для обозначения имен событий использовать константы класса. В предыдущем примере константа
 `EVENT_HELLO` обозначает событие `hello`. У такого подхода три преимущества. Во-первых, исключаются опечатки.
 Во-вторых, для событий работает автозавершение в различных средах разработки. В третьих, чтобы узнать, какие события
 поддерживаются классом, достаточно проверить константы, объявленные в нем.

Иногда при инициировании события может понадобиться передать его обработчику дополнительную информацию. Например,
объекту, отвечающему за почту, может понадобиться передать обработчику события `messageSent` определенные данные,
раскрывающие смысл отправленных почтовых сообщений. Для этого в качестве второго параметра методу
[[Jii.base.Component.trigger()]] передается объект события. Объект события должен быть экземпляром класса
[[Jii.base.Event]] или его потомка. Например:

```js
var Jii = require('jii');

/**
 * @class app.components.MessageEvent
 * @extends Jii.base.Component
 */
Jii.defineClass('app.components.MessageEvent', /** @lends app.components.MessageEvent.prototype */{

	__extends: Jii.base.Component,
	
	message: null

});

/**
 * @class app.components.Mailer
 * @extends Jii.base.Component
 */
Jii.defineClass('app.components.Mailer', /** @lends app.components.Mailer.prototype */{

	__extends: Jii.base.Component,
	
	__static: {
	    EVENT_MESSAGE_SENT: 'messageSent'
	},
	
	send: function(message) {
        // ...отправка message...

        var event = new app.components.MessageEvent();
        event.message = message;
        this.trigger(this.__static.EVENT_MESSAGE_SENT, event);
	}

});
```

При вызове метода [[Jii.base.Component.trigger()]] будут вызваны все обработчики, присоединенные к указанному событию.

Отсоединение обработчиков событий
------------------------

Для отсоединения обработчика от события используется метод [[Jii.base.Component.off()]]. Например:

```js
// обработчик - глобальная функция
foo.off(Foo.EVENT_HELLO, 'function_name');

// обработчик - метод объекта
foo.off(Foo.EVENT_HELLO, [object, 'methodName']);

// обработчик - статический метод класса
foo.off(Foo.EVENT_HELLO, ['app.components.Bar', 'methodName']);

// обработчик - анонимная функция
foo.off(Foo.EVENT_HELLO, anonymousFunction);
```

Учтите, что в общем случае отсоединять обработчики - анонимные функции можно только если они где-то сохраняются в
момент присоединения к событию. В предыдущем примере предполагается, что анонимная функция сохранена в переменной
`anonymousFunction`.

Чтобы отсоединить ВСЕ обработчики от события, достаточно вызвать [[Jii.base.Component.off()]] без второго параметра:

```js
foo.off(Foo.EVENT_HELLO);
```


Обработчики событий на уровне класса
--------------------------

Во всех предыдущих примерах мы рассматривали присоединение событий *на уровне экземпляров*. Есть случаи, когда
необходимо обрабатывать события, которые инициируются *любым* экземпляром класса, а не только конкретным экземпляром.
В таком случае присоединять обработчик события к каждому экземпляру класса не нужно. Достаточно присоединить обработчик
*на уровне класса*, вызвав статический метод [[Jii.base.Event.on()]].

Например, объект [Active Record](db-active-record) инициирует событие [[Jii.base.ActiveRecord.EVENT_AFTER_INSERT]]
после добавления в базу данных новой записи. Чтобы отслеживать записи, добавленные в базу данных *каждым* объектом
Active Record, можно использовать следующий код:

```js
Jii.base.Event.on(Jii.sql.ActiveRecord.className(), Jii.sql.ActiveRecord.EVENT_AFTER_INSERT, function (event) {
    Jii.trace(event.sender.className() + ' добавлен');
});
```

Обработчик будет вызван при срабатывании события [[Jii.base.ActiveRecord.EVENT_AFTER_INSERT]] в экземплярах класса
[[Jii.sql.ActiveRecord]] или его потомков. В обработчике можно получить доступ к объекту, который
инициировал событие, с помощью свойства `event.sender`.

При срабатывании события будут в первую очередь вызваны обработчики на уровне экземпляра, а затем - обработчики на
уровне класса.

Инициировать событие *на уровне класса* можно с помощью статического метода [[Jii.base.Event.trigger()]]. Событие
на уровне класса не связано ни с одним конкретным объектом. В таком случае будут вызваны только обработчики события
на уровне класса. Например:

```js
use Jii.base.Event;

Jii.base.Event.on(app.models.Foo.className(), app.models.Foo.EVENT_HELLO, function ($event) {
    console.log(event.sender); // app.models.Foo
});

Jii.base.Event.trigger(app.models.Foo.className(), app.models.Foo.EVENT_HELLO);
```

Обратите внимание, что в данном случае `event.sender` ссылается на имя класса, который инициировал событие, а не на
его экземпляр.

> Примечание: Поскольку обработчики на уровне класса отвечают на события, инициируемые всеми экземплярами этого
класса и всех его потомков, их следует использовать с осторожностью, особенно в случае базовых классов низкого уровня,
таких как [[Jii.base.Object]].

Отсоединить обработчик события на уровне класса можно с помощью метода [[Jii.base.Event.off()]]. Например:

```js
// отсоединение handler
Jii.base.Event.off(app.models.Foo.className(), app.models.Foo.EVENT_HELLO, handler);

// отсоединяются все обработчики Foo.EVENT_HELLO
Jii.base.Event.off(app.models.Foo.className(), app.models.Foo.EVENT_HELLO);
```


Глобальные события
-------------

Jii поддерживает так называемые *глобальные события*, которые на самом деле основаны на нестандартном использовании
описанного выше механизма событий. Для глобальных событий нужен глобально доступный объект-синглетон, например,
экземпляр приложения - [application](structure-applications).

Чтобы создать глобальное событие, отправитель сообщения вызывает метод `trigger()` синглетона, а не свой собственный
метод `trigger()`. Аналогичным образом обработчики события также присоединяются к событиям синглетона. Например:

```js
Jii.app.on('bar', function (event) {
    console.log(event.sender); // app.components.Foo
});

Jii.app.trigger('bar', new Event({sender: new Foo()}));
```

Преимущество глобальных событий в том, что им не нужен объект, к событию которого бы присоединялся обработчик и
объект, с помощью котрого бы это событие инициировалось. Вместо этого и для присоединения обработчика, и для
инициирования события используется синглетон (например, экземпляр приложения).

Тем не менее, так как пространство имен глобальных событий едино для всего приложения, их имена нельзя назначать
бездумно. Например, полезными могут быть искусственные пространства имен ("frontend.mail.sent", "backend.mail.sent").
