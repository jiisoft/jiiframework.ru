Модули
=======

Модули - это законченные программные блоки, состоящие из [моделей](structure-models),
[представлений](structure-views), [контроллеров](structure-controllers) и других вспомогательных компонентов.
При установке модулей в [приложение](structure-applications), конечный пользователь получает доступ к их
контроллерам. По этой причины модули часто рассматриваются как миниатюрные приложения. В отличии от
[приложений](structure-applications), модули нельзя развертывать отдельно. Модули должны находиться внутри приложений.

## Создание модулей <span id="creating-modules"></span>

Модуль помещается в директорию, которая называется [[Jii.base.Module.basePath|базовым путем]] модуля. Так же как и в
директории приложения, в этой директории существуют поддиректории `controllers`, `models`, `views` и другие, в
которых размещаются контроллеры, модели, представления и другие элементы. В следующем примере показано примерное
содержимое модуля:

```
modules/
    forum/
        Module.js                   файл класса модуля
        controllers/                содержит файлы классов контроллеров
            DefaultController.js    файл класса контроллера по умолчанию
        models/                     содержит файлы классов моделей
        views/                      содержит файлы представлений контроллеров и шаблонов
            layouts/                содержит файлы представлений шаблонов
            default/                содержит файлы представления контроллера DefaultController
                index.ejs           файл основного представления
```

### Классы модулей <span id="module-classes"></span>

Каждый модуль объявляется с помощью уникального класса, который наследуется от [[Jii.base.Module]]. Этот класс должен
быть помещен в корне [[Jii.base.Module.basePath|базового пути]] модуля. Во время запуска приложения (воркера) будет
создан один экземпляр соответствующего класса модуля. Как и [экземпляры приложения](structure-applications),
экземпляры модулей нужны, чтобы код модулей мог получить общий доступ к данным и компонентам.

Приведем пример того, как может выглядеть класс модуля:

```js
/**
 * @class app.modules.forum
 * @extends Jii.base.Module
 */
Jii.defineClass('app.modules.forum.Module', /** @lends app.modules.forum.Module.prototype */{

    __extends: Jii.base.Module,

    init: function(context) {
        this.params.foo = 'bar';
        
        return this.__super();
    }

});
```

### Контроллеры в модулях <span id="controllers-in-modules"></span>

При создании контроллеров модуля принято помещать классы контроллеров в подпространство `controllers` пространства
имен класса модуля. Это также подразумевает, что файлы классов контроллеров должны располагаться в директории
`controllers` [[Jii.base.Module.basePath|базового пути]] модуля. Например, чтобы описать контроллер `post` в модуле
`forum` из предыдущего примера, класс контроллера объявляется следующим образом:

```js
var Jii = require('jii');

/**
 * @class app.modules.forum.controllers.PostController
 * @extends Jii.base.Controller
 */
Jii.defineClass('app.modules.forum.controllers.PostController', /** @lends app.modules.forum.controllers.PostController.prototype */{

	__extends: Jii.base.Controller,


});
```

Изменить пространство имен классов контроллеров можно задав свойство [[Jii.base.Module.controllerNamespace]]. Если
какие-либо контроллеры выпадают из этого пространства имен, доступ к ним можно осуществить, настроив свойство
[[Jii.base.Module.controllerMap]], аналогично тому, как это делается в [приложении](structure-applications).

### Представления в модулях <span id="views-in-modules"></span>

Представления модуля также следует поместить в поддиректорию `views` [[Jii.base.Module.basePath|базового пути]] модуля.
Виды, которые рендерит контроллер модуля, должны располагаться в директории `views/ControllerID`, где `ControllerID`
соответствует [идентификатору контроллера](structure-controllers#routes). Например, если контроллер реализуется классом
`PostController`, представления следует разместить в поддиректории `views/post`
[[Jii.base.Module.basePath|базового пути]] модуля.

В модуле можно задать [шаблон](structure-views#layouts), который будет использоваться для рендеринга всех
представлений контроллерами модуля. По умолчанию шаблон помещается в директорию `views/layouts`, а свойство
[[Jii.base.Module.layout]] должно указывать на имя этого шаблона. Если не задать свойство `layout`, модуль будет
использовать шаблон, заданный в приложении.

## Использование модулей <span id="routes"></span>

Чтобы задействовать модуль в приложении, достаточно включить его в свойство [[Jii.base.Application.modules|modules]]
в конфигурации приложения. Следующий код в [конфигурации приложения](structure-applications#application-configurations) задействует модуль `forum`:

```js
{
    modules: {
        forum: {
            className: 'app\modules\forum\Module',
            // ... другие настройки модуля ...
        },
    },
}
```

Свойству [[Jii.base.Application.modules|modules]] присваивается объект, содержащий конфигурацию модуля. Каждый ключ
объекта представляет собой *идентификатор модуля*, который однозначно определяет модуль среди других модулей приложения,
а соответствующий объект - это [конфигурация](concept-configurations) для создания модуля.

### Маршруты <span id="routes"></span>

Как маршруты приложения используются для обращения к контроллерам приложения,
[маршруты](structure-controllers#routes) модуля используются, чтобы обращаться к контроллерам этого модуля.
Маршрут контроллера в модуле должен начинаться с идентификатора модуля, за которым следуют идентификатор контроллера
и идентификатор действия. Например, если в приложении задействован модуль `forum`, то маршрут `forum/post/index`
соответствует действию `index` контроллера `post` этого модуля. Если маршрут состоит только из идентификатора модуля,
то контроллер и действие определяются исходя из свойства [[Jii.base.Module.defaultRoute]], которое по умолчанию равно
`default`. Таким образом, маршрут `forum` соответствует контроллеру `default` модуля `forum`.

### Получение доступа к модулям <span id="accessing-modules"></span>

Зачастую внутри модуля может потребоваться доступ к экземпляру класса модуля, через который получаются идентификатор
модуля, его параметры, компоненты, и т. п. Доступ к экземпляру модуля можно получить следующими способами:

```js
var module = Jii.app.getModule('forum');
```
Имея экземпляр модуля можно получить доступ к параметрам и компонентам, зарегистрированным в модуле. Например,

```js
var maxPostCount = module.params.maxPostCount;
```

### Предзагрузка модулей <span id="bootstrapping-modules"></span>

Может потребоваться запускать некоторые модули при каждом запросе.
Например, следующая конфигурация приложения обеспечивает загрузку модуля `debug` в самом начале запуска приложения (воркера):

```js
{
    bootstrap: {
        'debug'
    },

    modules: {
        'debug' => 'jii.debug.Module'
    }
}
```

## Вложенные модули <span id="nested-modules"></span>

Модули могут вкладываться друг в друга без ограничений по глубине. Иными словами, в модуле содержится модуль,
в который входит еще один модуль, и т. д. Первый модуль называется *родительским*, остальные - *дочерними*.
Дочерние модули объявляются в свойстве [[Jii.base.Module.modules|modules]] родительских модулей. Например,

```js
/**
 * @class app.modules.forum
 * @extends Jii.base.Module
 */
Jii.defineClass('app.modules.forum.Module', /** @lends app.modules.forum.Module.prototype */{

    __extends: Jii.base.Module,

    init: function(context) {
        this.modules = {
            admin: {
                // здесь имеет смысл использовать более лаконичное пространство имен
                className => 'app.modules.forum.modules.admin.Module',
            }
        }
        
        return this.__super();
    }

});
```

Маршрут к контроллеру вложенного модуля должен содержать идентификаторы всех его предков. Например,
маршрут `forum/admin/dashboard/index` соответствует действию `index` контроллера `dashboard` модуля `admin`,
который в свою очередь является дочерним модулем модуля `forum`.

> Информация: Метод [[Jii.base.Module.getModule()|getModule()]] возвращает только те дочерние модули,
 которые принадлежат родительскому модулю непосредственно.
