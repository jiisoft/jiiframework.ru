Как это работает
=======

С первого взгляда, jii comet - это обертка над библиотекой комет-транспорта (sockjs, socket.io - на выбор),
однако это не так. От библиотеки транспорта берется только функционал доставки сообщения на клиент и обратно.
Реализация каналов, подписок, масштабирования и дополнительных фишек сделано именно в jii comet. Архитектурно 
"под капотом" jii comet разбит на следующие составляющие:

Сервер:

- Транспорт (`Jii.comet.server.transport.TransportInterface`) - абстракция для обмена сообщениями между клиентом и сервером. 
- Хаб (`Jii.comet.server.hub.HubInterface`) - абстракция для обмена сообщениями между процессами и серверами.
- Очередь (`Jii.comet.server.queue.QueueInterface`) - абстракция для накопления вызовов действий.
- Соединение (`Jii.comet.server.Connection`) - экземпляр данного класса содержит информацию о соединении и доступен
как [компонент контекста](structure-context-components).

Клиент:
- Транспорт (`Jii.comet.client.transport.TransportInterface`) - абстракция для обмена сообщениями между клиентом и сервером. 
- Плагин (`Jii.comet.client.plugin.PluginInterface`) - абстракция для расширения возможностей комет клиента. По-умолчанию,
установлен плагин для автоматического восстановления соединения `Jii.comet.client.plugin.AutoReconnect`.

Все эти абстракции могут настраиваться и переопределяться через [конфигурацию](concept-configurations) приложения и контекста.

## Примеры

Ниже рассмотрим несколько примеров того, как может ходить сообщение между клиентами и серверами. Предположим, что
в нашей системе имеется:
- несколько клиентов
- несколько серверных процессов только для поддержания соединений (`Jii.comet.server.Server` и `listenActions` = `false`)
- несколько серверных процессов для поддержания соединений и обработки действий (`Jii.comet.server.Server` и `listenActions` = `true`)
- несколько серверных процессов только для обработки действий (`Jii.comet.server.HubServer` и `listenActions` = `true`)

### Пример: Клиент отправляет сообщение в канал

![jii comet: Клиент отправляет сообщение в канал](/img/docs/jii-comet-channel-from-client.png)

1. Клиент отправляет сообщение в канал `test`.
2. Серверный процесс, поддерживающий соединение принимает это сообщение и отправляет в хаб (`Jii.comet.server.hub.HubInterface`).
3. Хаб рассылает это сообщение всем серверным процессам, которые подписаны на данный канал (или подписаны их соединения).
4. Серверные процессы получают сообщение и отправляют соединениям, которые на него подписаны.

### Пример: Клиент вызывает действие на сервере

![jii comet: Клиент вызывает действие на сервере](/img/docs/jii-comet-action.png)

1. Клиент отправляет запрос на вполнение действия `site/test`.
2. Серверный процесс, поддерживающий соединение принимает его и скидывает в очередь действий
(`Jii.comet.server.queue.QueueInterface`), а так же через хаб (`Jii.comet.server.hub.HubInterface`) рассылает уведомление
всем серверам, обрабатывающим действия (`listenActions` = `true`) о том, что очередь обновилась.
3. Один из серверных процессов с `listenActions` = `true` вытаскивает запрос из очереди (методом
[lpop](http://redis.io/commands/lpop) в имплементации Redis'а) и запускает у себя действие.
4. После выполнения действия, серверный процесс отправляет результат дейстивия (response) обратно клиенту. Поскольку
данный серверный процесс не имеет прямого соединения с клиентом, он отправляет его в хаб (`Jii.comet.server.hub.HubInterface`).
5. Хаб отправляет сообщение серверному процессу, подписаному на сообщения для этого соединения.
6. Серверный процесс, поддерживающий это соединение получает сообщение и отправляет его непосредственно клиенту.

В третьем пункте запрос из очереди мог вытянуть любой серверный процесс с `listenActions` = `true`. Работает это по
принципу "кто успел" и, как правило, успевать будет наименее нагруженный сервер. Таким образом, производится балансировка
вызовов действий между серверами и их процессами.

## Внутренний канал связи

Jii comet имеет абстракцию, позволяющую использовать любую библиотеку в качестве внутреннего
канала связи между клиентом и сервером. На данный момент сделан адаптер для библиотеки
[sockjs](https://github.com/sockjs/sockjs-client), в будущем появится и для [socket.io](http://socket.io/).

В конфигурации транспорт объявляется в секции `transport`. По-умолчанию, используется класс
`Jii.comet.server.transport.Sockjs` на севере и `Jii.comet.client.transport.Sockjs` на клиенте.
Транспорт можно конфигурировать и переопределять через конфигурацию:

```js
comet: {
    className: 'Jii.comet.client.Client',
    transport: {
        className: 'Jii.comet.client.transport.Sockjs',
        transports: [
            'websocket',
            'xhr-streaming',
            'xdr-streaming',
            'jsonp-polling'
        ]
    }
}
```

